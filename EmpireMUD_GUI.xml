<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>

<!-- TODO
icons for stats?
better tohit/dodge calculator
move gui show/hide to a button?
investigate white line below logo (rarely visible)
[it's in the image; will fix later]

Need icons for:
radiance
rejuvenate (cooldown and affect)
bash
backstab
jab (cooldown and affect?)
disarm (cooldown and affect)
stunned
shadowstep
alternate
teleport (home and city)
summon (thugs, animals, guards, humans)
blind (cooldown and affect)
entangle (cooldown and affect)
counterspell
boost
alacrity
claws
earthmeld
majesty
mummify?
soulmask?
weaken
reward cooldown
inspire affect
vigor penalty affect
phoenix rite affect
dispel and cleanse cooldowns
slow, siphon, enervate affects and cooldowns
mirrorimage cooldown
colorburst affect and cooldown
fly affect?
terrify
sap
prick cooldown
poison affects?
-->

<!-- Based heavily on KaVir's Generic GUI for MUSHClient 4.51-->

<muclient>
<plugin
   name="EmpireHUD"
   author="Hitsume"
   id="a0a8aa6fec64eaf933e2120a"
   language="Lua"
   purpose="A MSDP-based graphical interface for EmpireMUD Beta 2.9+."
   date_written="2015-09-16 07:45:00"
   requires="4.94"
   version="1.3"
   >

</plugin>
<!--  Aliases  -->

<aliases>
<alias script="gui_info" match="gui" enabled="y" sequence="100" ignore_case = "y" />
<alias script="gui_show" match="gui show" enabled="y" sequence="100" ignore_case="y" />
<alias script="gui_hide" match="gui hide" enabled="y" sequence="100" ignore_case="y" />
<alias script="gui_show" match="gui on" enabled="y" sequence="100" ignore_case="y" />
<alias script="gui_hide" match="gui off" enabled="y" sequence="100" ignore_case="y" />
<alias script="de_bug" match="gui debug" enabled="y" sequence="100" ignore_case ="y" />
</aliases>

<timers>
  <timer script="update_bars" name="bar_updater" second="0.10" enabled="y" offset_second="0.00" />
</timers>

<!--  Get our standard constants -->

<include name="constants.lua"/>

<!--  Script  -->

<script>
<![CDATA[
--latest
local using_msdp = false
local background_window = "world_background_image"  -- miniwindow ID
local border_window = "border_image"  -- miniwindow ID
local titlebar_window = "titlebar_image"  -- miniwindow ID
local avatar_window = "avatar_image"  -- miniwindow ID
local bars_window = "bars_image"  -- miniwindow ID
local bars_border_window = "bars_border"  -- miniwindow ID
local minimap_window = "minimap_image"  -- miniwindow ID
local minimap_border_window = "minimap_border"  -- miniwindow ID
local score_window = "score_image"  -- miniwindow ID
local score_border_window = "score_border"  -- miniwindow ID
local enemy_window = "enemy_window" --miniwindow ID
local enemy_border_window = "enemy_border_window" --miniwindow ID
local health_window = "health_bar"  -- miniwindow ID
local mana_window = "mana_bar"  -- miniwindow ID
local movement_window = "movement_bar"  -- miniwindow ID
local affect_window_prefix = "affect_window_" --miniwindow ID
local cooldown_window_prefix = "cooldown_window_" --miniwindow ID
local dot_window_prefix = "dot_window_" --miniwindow ID
local skill_hotspot_prefix = "hs_skill_"
local blood_window = "blood_bar"  -- miniwindow ID
local gui_on = true
local msdp = {}
-- configs:
local colourGold = ColourNameToRGB("gold")
local colourSilver = ColourNameToRGB("silver")
local colourBlack = ColourNameToRGB("black")
local colourRed = ColourNameToRGB("red")
local colourGreen = ColourNameToRGB("green")
local score_width = 257
local xpbar_width = score_width
local xpbar_height = 14
local primary_energy_bar_y_offset = 75
local energybar_width = score_width
local energybar_offset = 0
local energybar_height = 20
local energybar_spacing = 0
local energybar_update_ratio = 9/10 --update "speed" of energy bars (distance, not framerate)
local energybar_update_time = 0.1 --seconds, float, max ~59.9
local debug_mode = false
local path = "EmpireHUD"; --You may need to change this.
local font = "Verdana" --Font used for ALL graphical text.

function de_bug()
  if debug_mode then
    Note("Debug mode disabled.")
  else
    Note("Debug mode enabled.")
  end
  debug_mode = not debug_mode
end

function gui_info (name, line, wildcards)
  local vernum = GetPluginInfo(GetPluginID(), 19)
  Note("EmpireHUD v"..vernum.." by Hitsume is installed. The following commands are available:")
  Note("gui: shows this text.")
  Note("gui <hide/off>: Hides the GUI. You can also do this by disabling the plugin.")
  Note("gui <show/on>: Shows the GUI, if you used gui hide/off.")
  Note("gui debug: Shows MSDP-related (and other) debug messages. Can be quite spammy.")
end

function gui_show (name, line, wildcards)
  gui_on = true
  create_layout()
  -- redraw the enemy score window
  draw_enemy_window ()
  -- redraw the score sheet
  draw_score ()
  -- redraw the energy bars
  draw_energy_bars ()
  -- redraw the spell affect icons
  draw_affects ()
  
  Redraw()
--[[
  WindowShow(background_window, true)
  WindowShow(border_window, true)
  WindowShow(titlebar_window, true)
  WindowShow(avatar_window, true)
  WindowShow(bars_window, true)
  WindowShow(bars_border_window, true)
  WindowShow(minimap_window, true)
  WindowShow(minimap_border_window, true)
  WindowShow(score_window, true)
  WindowShow(score_border_window, true)
  WindowShow(health_window, true)
  WindowShow(mana_window, true)
  WindowShow(movement_window, true)
--]]
  ColourNote ("yellow", "", "GUI now shown. Type 'gui hide' to hide it.")
end --gui_show

function gui_hide (name, line, wildcards)
  if GetInfo(280)==nil or GetInfo(281) == nil then --may fix runtime errors if MUSHclient is closed while world is open
    return
  end
  gui_on = false
  WindowShow(background_window, false)
  WindowShow(border_window, false)
  WindowShow(titlebar_window, false)
  WindowShow(avatar_window, false)
  WindowShow(bars_window, false)
  WindowShow(bars_border_window, false)
  WindowShow(minimap_window, false)
  WindowShow(minimap_border_window, false)
  WindowShow(score_window, false)
  WindowShow(score_border_window, false)
  WindowShow(health_window, false)
  WindowShow(mana_window, false)
  WindowShow(blood_window, false)
  WindowShow(movement_window, false)
  WindowShow(enemy_window, false)
  WindowShow(enemy_border_window, false)
  local i = 1
  local status = true
  local error = nil
  --this hack hides affect icons
  while status and i<256 do
--    status, error = pcall(WindowShow(affect_window_prefix..i, false))
    error = WindowShow(affect_window_prefix..i, false)
    i=i+1
  end
  i = 1
  while status and i<256 do
--    status, error = pcall(WindowShow(affect_window_prefix..i, false))
    error = WindowShow(cooldown_window_prefix..i, false)
    i=i+1
  end
  i = 1
  while status and i<256 do
--    status, error = pcall(WindowShow(affect_window_prefix..i, false))
    error = WindowShow(dot_window_prefix..i, false)
    i=i+1
  end
  SetBackgroundImage("", 0)
  TextRectangle(
                0,
                0,
                GetInfo (281),
                GetInfo (280),
                1,  -- BorderOffset, 
                colourGold,    -- BorderColour, 
                1,  -- BorderWidth, 
                colourGold,  -- OutsideFillColour, 
                8) -- OutsideFillStyle (fine hatch)
  ColourNote ("yellow", "", "GUI now hidden. Type 'gui show' to show it.")
end --gui_hide

function OnPluginEnable ()
  gui_show ()
end -- OnPluginDisable

function OnPluginDisable ()
  gui_hide ()
end -- OnPluginDisable

-- hide window on removal
function OnPluginClose ()
  gui_hide ()
end

function OnPluginInstall ()
  SetTimerOption("bar_updater", "second", energybar_update_time)
  gui_show ()
end

left = 15 -- was 175
top = 73
right_offset = -307
bottom_offset = -15
score_border = 15
score_left_offset = 25 --formerly 34
score_top_offset = 11
local primary_energy_bar_x_offset = score_left_offset --used to be up at the top with y_offset...

right = GetInfo (281) + right_offset
bottom = GetInfo (280) + bottom_offset  -- 32 pixels from bottom


--draw window borders - used to be done inside create_layout, but it was repeated practically the same way every time
function draw_borders (window, x, y)
  -- load the left border image
  if WindowLoadImage (window, "border_left", GetInfo (66) .. path .. "/layout/border_left.png") == eOK then
    check (WindowDrawImage (window, "border_left", 0, 0, 0, 0, 1))  -- draw it
  else -- the file is missing
    Note( "File '" .. GetInfo (66) .. path .. "/layout/border_left.png' is missing.")
  end -- if

  -- load the right border image
  if WindowLoadImage (window, "border_right", GetInfo (66) .. path .. "/layout/border_right.png") == eOK then
    check (WindowDrawImage (window, "border_right", x, 0, 0, 0, 1))  -- draw it
  else -- the file is missing
    Note( "File '" .. GetInfo (66) .. path .. "/layout/border_right.png' is missing.")
  end -- if

  -- load the top border image
  if WindowLoadImage (window, "border_top", GetInfo (66) .. path .. "/layout/border_top.png") == eOK then
    check (WindowDrawImage (window, "border_top", 0, 0, 0, 0, 1))  -- draw it
  else -- the file is missing
    Note( "File '" .. GetInfo (66) .. path .. "/layout/border_top.png' is missing.")
  end -- if

  -- load the bottom border image
  if WindowLoadImage (window, "border_bottom", GetInfo (66) .. path .. "/layout/border_bottom.png") == eOK then
    check (WindowDrawImage (window, "border_bottom", 0, y, 0, 0, 1))  -- draw it
  else -- the file is missing
    Note( "File '" .. GetInfo (66) .. path .. "/layout/border_top.png' is missing.")
  end -- if

  -- load the top right corner image
  if WindowLoadImage (window, "corner_tr", GetInfo (66) .. path .. "/layout/corner_tr.png") == eOK then
    check (WindowDrawImage (window, "corner_tr", x, 0, 0, 0, 1))  -- draw it
  else -- the file is missing
    Note( "File '" .. GetInfo (66) .. path .. "/layout/corner_tr.png' is missing.")
  end -- if

  -- load the bottom right corner image
  if WindowLoadImage (window, "corner_br", GetInfo (66) .. path .. "/layout/corner_br.png") == eOK then
    check (WindowDrawImage (window, "corner_br", x, y, 0, 0, 1))  -- draw it
  else -- the file is missing
    Note( "File '" .. GetInfo (66) .. path .. "/layout/corner_br.png' is missing.")
  end -- if
end

-- create the layout here, on getting the prompt, or window resize
function create_layout ()
  if not gui_on then return end

  if GetInfo(280)==nil or GetInfo(281) == nil then --may fix runtime errors if MUSHclient is closed while world is open
    return
  end
  
  right = GetInfo (281) + right_offset
  bottom = GetInfo (280) + bottom_offset


  score_left = right+score_left_offset
  score_top = top+score_top_offset
  
  -- if its less than this, we lose the map
  min_width = 50 + GetInfo (213) * 81 -- offset + width for 81 characters
  if right < min_width then
    right = min_width
  end -- if

  -- avoid the plugin crashing if someone makes the window stupidly small
  if bottom < top then
    bottom = top
  end -- if

  ----------------------------------------------------------------------------
  -- Set the background, using the textured tile.
  ----------------------------------------------------------------------------

  SetBackgroundImage(GetInfo (66) .. path .. "/layout/outer_background.png", 13)

  ----------------------------------------------------------------------------
  -- Set the main text area.
  ----------------------------------------------------------------------------

  -- tell the client where to draw the text
  TextRectangle(left+13,  
                top+13,   
                right-13,
                bottom-13,  
                1,  -- BorderOffset, 
                colourGold,    -- BorderColour, 
                1,  -- BorderWidth, 
                colourGold,  -- OutsideFillColour, 
                8) -- OutsideFillStyle (fine hatch)

  ----------------------------------------------------------------------------
  -- Create a black window over the text area, behind the text.
  ----------------------------------------------------------------------------

  -- make a miniwindow under the text
  if WindowCreate (border_window,   -- window ID
                left-5, 
                top-5,   
                right - left + 10, -- width
                bottom - top + 10, -- depth
                12,  -- center it (ignored anyway) 
                3,   -- draw underneath (1) + absolute location (2)
                0x000000) ~= eOK then
    -- problem creating the window.  Not sure why this happens, but it some 
    -- players have encountered a depth of -3, which causes the plugin to crash.
    return
  end -- if

  -- show the window
--  WindowShow (border_window, true)


  -- make a miniwindow under the text
  if WindowCreate (background_window,   -- window ID
                left-4, 
                top-4,   
                right - left + 8, -- width
                bottom - top + 8, -- depth
                12,  -- center it (ignored anyway) 
                3,   -- draw underneath (1) + absolute location (2)
                0x000000) ~= eOK then
    -- problem creating the window.  Not sure why this happens, but it some 
    -- players have encountered a depth of -3, which causes the plugin to crash.
    return
  end -- if

  -- load the paper background image
  if WindowLoadImage (background_window, "background_background", GetInfo (66) .. path .. "/layout/inner_background.png") == eOK then
    check (WindowDrawImage (background_window, "background_background", 0, 0, 0, 0, 1))  -- draw it
  else -- the file is missing
    Note( "File '" .. GetInfo (66) .. path .. "/layout/inner_background.png' is missing.")
  end -- if

  draw_borders(background_window, right-left-7, bottom-top-7)

  -- show the window
  WindowShow (background_window, true)

  ----------------------------------------------------------------------------
  -- Create the EmpireHUD title at the top of the screen.
  ----------------------------------------------------------------------------

  width_of_title_image = 358

  title_x = (GetInfo (281) - width_of_title_image) / 2

  -- make a miniwindow to the left of the text
  check (WindowCreate (titlebar_window,   -- window ID
                title_x,   -- left
                0,   -- top
                981, -- width
                187, -- depth
                12,  -- center it (ignored anyway) 
                7,          -- draw underneath (1) + absolute location (2) + transparent (4)
                0x000000))  -- background colour

  -- load the titlebar image
  check (WindowLoadImage (titlebar_window, "titlebar", GetInfo (66) .. path .. "/layout/Title.png"))

  -- draw it
  check (WindowDrawImage (titlebar_window, "titlebar", 0, -20, 0, 0, 3))  -- draw it

  -- show the window
  WindowShow (titlebar_window, true)

  ----------------------------------------------------------------------------
  -- Create the bars window to the left of the text.
  ----------------------------------------------------------------------------
--[[
  -- make a miniwindow for the graphical border
  check (WindowCreate (bars_border_window,   -- window ID
                14,         -- left
                top-4,      -- top
                142,        -- width
                142,        -- depth
                12,         -- center it (ignored anyway) 
                2,          -- draw underneath (1) + absolute location (2)
                0x000000))  -- background colour

  -- make a miniwindow for the map
  check (WindowCreate (bars_window,   -- window ID
                29,         -- left
                top+11,     -- top
                112,        -- width
                112,        -- depth
                12,         -- center it (ignored anyway) 
                2,          -- draw underneath (1) + absolute location (2)
                0x000000))  -- background colour

  draw_borders(bars_border_window, 110+17, 110+17)

  -- load the paper background image
  if WindowLoadImage (bars_window, "bars_background", GetInfo (66) .. path .. "/layout/inner_background.png") == eOK then
    check (WindowDrawImage (bars_window, "bars_background", 0, 0, 0, 0, 1))  -- draw it
  else -- the file is missing
    Note( "File '" .. GetInfo (66) .. path .. "/layout/inner_background.png' is missing.")
  end -- if

  -- show the window and its border
  WindowShow (bars_border_window, true)
  WindowShow (bars_window, true)
--]]
  ----------------------------------------------------------------------------
  -- Create the minimap window to the left of the text.
  ----------------------------------------------------------------------------
--[[
  -- make a miniwindow for the graphical border
  check (WindowCreate (minimap_border_window,   -- window ID
                14,         -- left
                top+153,    -- top
                142,        -- width
                142,        -- depth
                12,         -- center it (ignored anyway) 
                2,          -- draw underneath (1) + absolute location (2)
                0x000000))  -- background colour

  -- make a miniwindow for the map
  check (WindowCreate (minimap_window,   -- window ID
                29,         -- left
                top+168,    -- top
                112,        -- width
                112,        -- depth
                12,         -- center it (ignored anyway) 
                2,          -- draw underneath (1) + absolute location (2)
                0x000000))  -- background colour

  draw_borders(minimap_border_window, 110+17, 110+17)

  -- load the paper background image
  if WindowLoadImage (minimap_window, "minimap_background", GetInfo (66) .. path .. "/layout/inner_background.png") == eOK then
    check (WindowDrawImage (minimap_window, "minimap_background", 0, 0, 0, 0, 1))  -- draw it
  else -- the file is missing
    Note( "File '" .. GetInfo (66) .. path .. "/layout/inner_background.png' is missing.")
  end -- if

  -- show the window and its border
  WindowShow (minimap_border_window, true)
  WindowShow (minimap_window, true)

  -- load the terrain images
  check (WindowLoadImage (minimap_window, "terrain_city", GetInfo (66) .. path .. "/maps/terrain_city.bmp"))
  check (WindowLoadImage (minimap_window, "terrain_dark", GetInfo (66) .. path .. "/maps/terrain_dark.bmp"))

  -- draw the map
  draw_minimap ()
--]]

  check (WindowCreate (enemy_border_window,   -- window ID
                score_left-score_border,         -- left
                15-score_border,    -- top
                score_width+2*score_border,        -- width
                score_top-score_border-5,            -- depth
                12,         -- center it (ignored anyway) 
                2,          -- draw underneath (1) + absolute location (2)
                0x000000))  -- background colour

  -- make a miniwindow for the enemy score
  enemy_window_height = score_top-score_border*3-5
  check (WindowCreate (enemy_window,   -- window ID
                score_left,         -- left
                15,    -- top
                score_width,        -- width
                enemy_window_height,        -- depth
                12,         -- center it (ignored anyway) 
                2,          -- draw underneath (1) + absolute location (2)
                0x000000))  -- background colour
                
  draw_borders(enemy_border_window, score_width+15, score_top-score_border-5-15)
  WindowAddHotspot(enemy_window,  "hs_enemy", 0, 0, score_width, enemy_window_height, "", "", "", "", "", "Enemy", 12, 0)
  outlined_text(colourGold, enemy_border_window, "Enemy", 9, score_border, 0, score_width)
  if WindowLoadImage (enemy_window, "score_background", GetInfo (66) .. path .. "/layout/inner_background.png") == eOK then
    check (WindowDrawImage (enemy_window, "score_background", 0, 0, 0, 0, 1))  -- draw it
  else -- the file is missing
    Note( "File '" .. GetInfo (66) .. path .. "/layout/inner_background.png' is missing.")
  end -- if
  
  draw_enemy_window()
  --show the window and its border
  WindowShow(enemy_border_window)
  WindowShow(enemy_window)

  ----------------------------------------------------------------------------
  -- Create the score window to the right of the text.
  ----------------------------------------------------------------------------

  -- make a miniwindow for the graphical border
  check (WindowCreate (score_border_window,   -- window ID
                score_left-score_border,   -- left
                score_top-score_border,      -- top
                score_width+2*score_border,        -- width
                bottom - top + 8, -- depth
                12,         -- center it (ignored anyway) 
                2,          -- draw underneath (1) + absolute location (2)
                0x000000))  -- background colour

  -- make a miniwindow for the inner area
  local height = math.max(5,bottom-top-22)
--[[  Tell("x:")
  Tell(right+34)
  Tell(",")
  Tell(34+score_width)
  Tell(",y:")
  Tell(top+11)
  Tell(",")
  Tell(height)
  Note("")]]
  check (WindowCreate (score_window,   -- window ID
                score_left, -- left
                score_top,  -- top
                score_width,-- width
                height,     -- depth
                12,         -- center it (ignored anyway) 
                2,          -- draw underneath (1) + absolute location (2)
                0x000000))  -- background colour
  --add hotspots, for tooltips; more are added later
  WindowAddHotspot(score_window, "hs_terr", 0, 0, 1, 1, "", "", "", "", "", "Territory", 12, 0);
  WindowAddHotspot(score_window, "hs_level", 0, 0, 1, 1, "", "", "", "", "", "Strength", 12, 0);
  WindowAddHotspot(score_window, "hs_str", 0, 0, 1, 1, "", "", "", "", "", "Strength", 12, 0);
  WindowAddHotspot(score_window, "hs_dex", 0, 0, 1, 1, "", "", "", "", "", "Dexterity", 12, 0);
  WindowAddHotspot(score_window, "hs_int", 0, 0, 1, 1, "", "", "", "", "", "Intelligence", 12, 0);
  WindowAddHotspot(score_window, "hs_wit", 0, 0, 1, 1, "", "", "", "", "", "Wits", 12, 0);
  WindowAddHotspot(score_window, "hs_cha", 0, 0, 1, 1, "", "", "", "", "", "Charisma", 12, 0);
  WindowAddHotspot(score_window, "hs_grt", 0, 0, 1, 1, "", "", "", "", "", "Greatness", 12, 0);
  WindowAddHotspot(score_window, "hs_tohit", 0, 0, 1, 1, "", "", "", "", "", "To-hit", 12, 0);
  WindowAddHotspot(score_window, "hs_dodge", 0, 0, 1, 1, "", "", "", "", "", "Dodge", 12, 0);
  WindowAddHotspot(score_window, "hs_block", 0, 0, 1, 1, "", "", "", "", "", "Block", 12, 0);
  WindowAddHotspot(score_window, "hs_resist", 0, 0, 1, 1, "", "", "", "", "", "Resist", 12, 0);
  WindowAddHotspot(score_window, "hs_phys", 0, 0, 1, 1, "", "", "", "", "", "Bonus-Physical", 12, 0);
  WindowAddHotspot(score_window, "hs_magic", 0, 0, 1, 1, "", "", "", "", "", "Bonus-Magical", 12, 0);
  WindowAddHotspot(score_window, "hs_heal", 0, 0, 1, 1, "", "", "", "", "", "Bonus-Healing", 12, 0);
  
  draw_borders(score_border_window, score_width+15, bottom-top-7) --145+110+17

  -- load the paper background image
  if WindowLoadImage (score_window, "score_background", GetInfo (66) .. path .. "/layout/inner_background.png") == eOK then
    check (WindowDrawImage (score_window, "score_background", 0, 0, 0, 0, 1))  -- draw it
  else -- the file is missing
    Note( "File '" .. GetInfo (66) .. path .. "/layout/inner_background.png' is missing.")
  end -- if

  -- load the avatar image
  if WindowLoadImage (score_window, "avatar", GetInfo (66) .. path .. "/avatars/Default.png") ~= eOK then
    Note( "File '" .. GetInfo (66) .. path .. "/avatars/Default.png' is missing.")
  end -- if

  -- fill in the window
  draw_score ()

  -- draw the spell affect icons
  draw_affects ()
  
  -- show the window and its border
  WindowShow (score_border_window, true)
  WindowShow (score_window, true)

  ----------------------------------------------------------------------------
  -- Create the actual health, mana and movement bars' windows.
  ----------------------------------------------------------------------------

  -- make a miniwindow under the text
  check (WindowCreate (health_window,   -- window ID
                right+primary_energy_bar_x_offset+energybar_offset,      -- left
                top+primary_energy_bar_y_offset,        -- top
                energybar_width,   -- width
                energybar_height,            -- depth
                12,            -- center it (ignored anyway) 
                2,             -- draw underneath (1) + absolute location (2)
                colourBlack))  -- background colour

  -- show the window
  WindowShow (health_window, true)
  WindowSetZOrder (health_window, 20) --draw on top of other windows
  WindowAddHotspot(health_window, "hs_tooltip", 0, 0, energybar_width, energybar_height, "", "", "", "", "", "This is a tooltip!", 12, 0)
  
  -- make a miniwindow under the text
  check (WindowCreate (mana_window,   -- window ID
                right+primary_energy_bar_x_offset+energybar_offset,      -- left
                top+primary_energy_bar_y_offset+energybar_height+energybar_spacing,        -- top
                energybar_width,   -- width
                energybar_height,            -- depth
                12,            -- center it (ignored anyway) 
                2,             -- draw underneath (1) + absolute location (2)
                colourBlack))  -- background colour

  -- show the window
  WindowShow (mana_window, true)
  WindowSetZOrder (mana_window, 20)
  WindowAddHotspot(mana_window, "hs_tooltip", 0, 0, energybar_width, energybar_height, "", "", "", "", "", "This is a tooltip!", 12, 0)
  
  -- make a miniwindow under the text
  check (WindowCreate (movement_window,   -- window ID
                right+primary_energy_bar_x_offset+energybar_offset,      -- left
                top+primary_energy_bar_y_offset+(energybar_height+energybar_spacing)*2,       -- top
                energybar_width,   -- width
                energybar_height,            -- depth
                12,            -- center it (ignored anyway) 
                2,             -- draw underneath (1) + absolute location (2)
                colourBlack))  -- background colour

  -- show the window
  WindowShow (movement_window, true)
  WindowSetZOrder (movement_window, 20)
  WindowAddHotspot(movement_window, "hs_tooltip", 0, 0, energybar_width, energybar_height, "", "", "", "", "", "This is a tooltip!", 12, 0)
  
  -- make a miniwindow under the text
  check (WindowCreate (blood_window,   -- window ID
                right+primary_energy_bar_x_offset+energybar_offset,            -- left
                top+primary_energy_bar_y_offset+(energybar_height+energybar_spacing)*3,           -- top
                energybar_width,   -- width
                energybar_height,            -- depth
                12,            -- center it (ignored anyway) 
                2,             -- draw underneath (1) + absolute location (2)
                colourBlack))  -- background colour

  -- show the window
  WindowShow (blood_window, true)
  WindowSetZOrder (blood_window, 20)
  WindowAddHotspot(blood_window, "hs_tooltip", 0, 0, energybar_width, energybar_height, "", "", "", "", "", "This is a tooltip!", 12, 0)
  -- draw the energy bars
  draw_energy_bars ()

end -- create_layout


function OnPluginWorldOutputResized ()
  create_layout ()
end -- function


local RoomExit = {}
local RoomType = {}
local ExitCount = 0

--for the minimap. Deprecated.
function init_rooms (data)

  ExitCount = 0

  index = 0
  startpos = 1
  local max = 0
  for i=startpos,string.len(data),1 do
    if string.byte(data,i) == 1 or i == string.len(data) then
      if string.byte(data,i) == 1 then
        endpos = 1
      else
        endpos = 0
      end -- if
      variable = string.sub(data,startpos,i-endpos)
      startpos = i+1
      index = index + 1

      pos1 = string.find(variable, "\002")
      if pos1 ~= nil then
        RoomExit[index] = string.sub(variable, 1, pos1-1)
        RoomType[index] = string.sub(variable, pos1+1)
        ExitCount = ExitCount + 1
      end -- if
    end -- if
  end -- for

end -- function


-- draw one room. For the minimap; deprecated.
function draw_room (x, y, type)

  terrain_image = "terrain_dark"
  if type == "O" then
    terrain_image = "terrain_city"
  end -- if

  WindowCircleOp (minimap_window, 2, x-1, y-1, x+22, y+22, colourGold, 0, 2, 0, 1)
  WindowCircleOp (minimap_window, 2, x-1, y-1, x+21, y+21, colourBlack, 0, 1, 0, 1)
  WindowDrawImage (minimap_window, terrain_image, x, y, x+20, y+20, 1)  -- draw the terrain

end -- draw_room


-- draw the minimap. Deprecated.
function draw_minimap ()

  data = msdp["ROOM_EXITS"]

  if data ~= nil then
    init_rooms (data)
  end -- if

  mapCentre = 45

  -- clean the background and redraw the central room
  check (WindowDrawImage (minimap_window, "minimap_background", 0, 0, 0, 0, 1))  -- draw it
  draw_room (mapCentre, mapCentre, "O")

  -- draw any surrounding rooms
  if ExitCount > 0 then
    for i=1,ExitCount,1 do
      if RoomExit[i] == "north" then
        draw_room(mapCentre, mapCentre-30, RoomType[i])
        WindowLine(minimap_window, mapCentre+9, mapCentre-2, mapCentre+9, mapCentre-10, colourGold, 0, 1)
        WindowLine(minimap_window, mapCentre+10, mapCentre-2, mapCentre+10, mapCentre-10, colourGold, 0, 1)
      elseif RoomExit[i] == "south" then
        draw_room(mapCentre, mapCentre+30, RoomType[i])
        WindowLine(minimap_window, mapCentre+9, mapCentre+28, mapCentre+9, mapCentre+20, colourGold, 0, 1)
        WindowLine(minimap_window, mapCentre+10, mapCentre+28, mapCentre+10, mapCentre+20, colourGold, 0, 1)
      elseif RoomExit[i] == "east" then
        draw_room(mapCentre+30, mapCentre, RoomType[i])
        WindowLine(minimap_window, mapCentre+22, mapCentre+9, mapCentre+28, mapCentre+9, colourGold, 0, 1)
        WindowLine(minimap_window, mapCentre+22, mapCentre+10, mapCentre+28, mapCentre+10, colourGold, 0, 1)
      elseif RoomExit[i] == "west" then
        draw_room(mapCentre-30, mapCentre, RoomType[i])
        WindowLine(minimap_window, mapCentre-3, mapCentre+9, mapCentre-10, mapCentre+9, colourGold, 0, 1)
        WindowLine(minimap_window, mapCentre-3, mapCentre+10, mapCentre-10, mapCentre+10, colourGold, 0, 1)
      end -- if
    end -- for
  end -- if

end -- draw_minimap


-- fill the three energy bars
function draw_energy_bars ()

  -- HEALTH
  current_health = msdp["HEALTH"]
  max_health = msdp["HEALTH_MAX"]
  health_regen = msdp["HEALTH_REGEN"]

  -- initialise with empty bars
  if current_health == nil then
    current_health = 0
    max_health = 0
  end -- if

  if current_health ~= nil and max_health ~= nil then
    local type = "Health"
    colour = 0x0000AA
    colour2 = 0x000033
    colour3 = 0x0000FF
    colour4 = 0xAAAAAA
    draw_energy_bar(type, colour, colour2, colour3, colour4, health_window, current_health, max_health, last_health, health_regen)
  end -- if
  --update the "previous value"

  if last_health == nil or os.time()-last_health_time>=2 then
    last_health = current_health
  end
  last_health_time = os.time()
  
  -- MANA
  current_mana = msdp["MANA"]
  max_mana = msdp["MANA_MAX"]
  mana_regen = msdp["MANA_REGEN"]

  -- initialise with empty bars
  if current_mana == nil then
    current_mana = 0
    max_mana = 0
  end -- if

  if current_mana ~= nil and max_mana ~= nil then
    local type = "Mana"
    colour = 0xAA0000
    colour2 = 0x330000
    colour3 = 0xFF0000
    colour4 = 0xAAAAAA
    draw_energy_bar(type, colour, colour2, colour3, colour4, mana_window, current_mana, max_mana, last_mana, mana_regen)
  end -- if
  --update the "previous time"

  if last_mana == nil or os.time()-last_mana_time>=2 then
    last_mana = current_mana
  end
  last_mana_time = os.time()
  
  -- MOVEMENT
  current_movement = msdp["MOVEMENT"]
  max_movement = msdp["MOVEMENT_MAX"]
  movement_regen = msdp["MOVEMENT_REGEN"]
  
  -- initialise with empty bars
  if current_movement == nil then
    current_movement = 0
    max_movement = 0
  end -- if
  
  if current_movement ~= nil and max_movement ~= nil then
    local type = "Move"
    colour = 0x00AA00
    colour2 = 0x003300
    colour3 = 0x00FF00
    colour4 = 0xAAAAAA
    draw_energy_bar(type, colour, colour2, colour3, colour4, movement_window, current_movement, max_movement, last_movement, movement_regen)
  end -- if
  --update the "previous value"

  if last_movement == nil or os.time()-last_movement_time>=2 then
    last_movement = current_movement
  end
  last_movement_time = os.time()
  
  -- Blood
  current_blood = msdp["BLOOD"]
  max_blood = msdp["BLOOD_MAX"]
  if msdp["BLOOD_UPKEEP"]~= nil then
    blood_regen = ""..tonumber(msdp["BLOOD_UPKEEP"]) * -1
  end
  
  -- initialise with empty bars
  if current_blood == nil then
    current_blood = 0
    max_blood = 0
  end -- if
  local skills = unpack_array(msdp["SKILLS"])
  local vamp = nil
  if skills then vamp = skills["Vampire"] end
  if gui_on and current_blood ~= nil and max_blood ~= nil and vamp ~= nil and ((vamp["LEVEL"] ~= nil and vamp["LEVEL"] ~= 0) or (vamp["EXP"] ~= nil and vamp["EXP"] ~= 0)) then
    local type = "Blood"
    colour = 0x0000CC
    colour2 = 0x000033
    draw_energy_bar(type, colour, colour2, colour3, colour4, blood_window, current_blood, max_blood, last_blood, blood_regen)
    WindowShow(blood_window, true)
    no_blood = false --used to position the rest of the score
  else
    no_blood = true
    WindowShow(blood_window, false) --hide the blood bar
  end -- if
  
  --update the "previous value"
  if last_blood == nil or os.time()-last_blood_time>=1 then
    last_blood = current_blood
  end
  last_blood_time = os.time()
end -- draw_energy_bars

function draw_mini_bar (colour, colour2, window, x_offset, y_offset, width, height, current_value, max_value)
  current = tonumber(current_value)
  max = tonumber(max_value)

  WindowGradient (window, x_offset, y_offset-1, width+x_offset, y_offset+height/2, colourBlack, colour2, 2)
  WindowGradient (window,  x_offset, y_offset+height/2, width+x_offset, y_offset+height+1, colour2, colourBlack, 2)

  if max > 0 then
    filled = current / max
  else -- avoid division by zero
    filled = 0
  end -- if
  -- redraw the bars
  if current > 0 then
    --ceil is required to avoid very nearly empty bars appearing full
    --(if filled is small enough to make filled*width a fraction)
    WindowGradient (window, x_offset, y_offset-1, math.ceil(filled*width)+x_offset, y_offset+height/2, colourBlack, colour, 2)
    WindowGradient (window, x_offset, y_offset+height/2, math.ceil(filled*width)+x_offset, y_offset+height+1, colour, colourBlack, 2)
  end
end

--Draws skill experience bars for the score window.
function draw_xp_bar (skill, colour, colour2, window, x_offset, y_offset, current_value, max_value, level_value)
  -- convert the strings to numbers
--  Note(current_value.."/"..max_value)
  local current = tonumber(current_value)
  local max = tonumber(max_value)
  if level_value==nil then level_value = "0" end
  local level = tonumber(level_value)
  -- Apply limits
  if current < 0 then
    current = 0
  elseif current > max then
    current = max
  end -- if
  -- Draw the empty bars (clears the old ones)
  local height = xpbar_height
  WindowGradient (window, x_offset, y_offset-1, xpbar_width+x_offset, y_offset+height/2, colourBlack, colour2, 2)
  WindowGradient (window, x_offset, y_offset+height/2, xpbar_width+x_offset, y_offset+height+1, colour2, colourBlack, 2)
  
  -- calculate the filled part
  if max > 0 then
    filled = current / max
  else -- avoid division by zero
    filled = 0
  end -- if
--  Note(skill..":"..filled..":"..(filled*xpbar_width))
  -- redraw the bars
  if current > 0 then
    --ceil is required to avoid very nearly empty bars appearing full
    --(if filled is small enough to make filled*xpbar_width a fraction)
    WindowGradient (window, x_offset, y_offset-1, math.ceil(filled*xpbar_width)+x_offset, y_offset+height/2, colourBlack, colour, 2)
    WindowGradient (window, x_offset, y_offset+height/2, math.ceil(filled*xpbar_width)+x_offset, y_offset+height+1, colour, colourBlack, 2)
  end
  
  -- write the information inside
  outlined_text (colourGold, window, level, 8, x_offset+27, y_offset+(height-14)/2, 0, true) --level
  outlined_text (colourGold, window, skill, 8, x_offset+33, y_offset+(height-14)/2, 0) --skill
  outlined_text (colourGold, window, (math.ceil(filled*1000)/10)..'%', 8, x_offset+xpbar_width-3, y_offset+(height-14)/2, 0, true) --xp%
  
end --of draw_xp_bar

local energy_prev = {}
local energy_current = {}
local energy_max = {}
--used to pass information to update_bar
local energy_colours = {}
local energy_windows = {}

-- Draw the individual energy bars (health, mana, moves, blood)
function draw_energy_bar (type, colour, colour2, colour3, colour4, window, current_value, max_value, previous_value, regen)
  -- convert the strings to numbers
  energy_current[type] = tonumber(current_value) or 0
  energy_max[type] = tonumber(max_value) or 0
  if previous_value == nil then previous_value = "0" end
  if regen == nil then regen = "0" end
  --Note(type..", "..current_value..", "..max_value..", "..previous_value)
--  previous = tonumber(previous_value)
  -- Apply limits
  
  if energy_current[type] < 0 then
    energy_current[type] = 0
  elseif energy_current[type] > energy_max[type] then
    energy_current[type] = energy_max[type]
  end -- if
  -- Apply limits
--  if previous < 0 then previous = 0 elseif previous > max then previous = max end
  -- clear the bars
  
  --figure out the regen time
  local regentime
  local regentime_string
  if tonumber(regen) < 0 then
    --Regen is negative for blood. TODO: check type=="Blood"?
    regentime = math.ceil(energy_current[type]/(tonumber(regen)/-75))
    regentime_string = seconds_to_minutes(regentime).."."
  elseif tonumber(regen) == 0 then
    regentime = -1
    regentime_string = "Never."
  else
    regentime = math.ceil((energy_max[type]-energy_current[type])/(tonumber(regen)))*5
    if regentime >= 60 then regentime_string = seconds_to_minutes(regentime).."." else regentime_string = regentime.." seconds." end
    --"25 seconds." or "3:35."
  end
  --set the tooltip
  local line1 = ""
  local line2 = ""
  if type == "Blood" then
    if tonumber(regen) < 0 then
        line2 = "\nWill last: "..regentime_string
    end
    line1 = "Spending "..(tonumber(regen)*-1).." per 75 seconds."
  else
    if tonumber(regentime) > 0 then
      line2 = "\nWill be full in: "..regentime_string
    end
    line1 = "Regenerating "..regen.." per 5 seconds."
  end
  WindowHotspotTooltip(window, "hs_tooltip", line1..line2)
  -- redraw the bars
  if energy_prev[type] == nil then energy_prev[type] = energy_current[type] end
  local loops = 0

  energy_colours[type] = {colour, colour2, colour3, colour4}
  energy_windows[type] = window
  update_bar(type)
end -- draw_energy_bar

function update_bars()
  if debug_mode then
   -- Note("updating bars")
  end
  for k, v in pairs(energy_current) do --[[if debug_mode then Note(k..": "..energy_prev[k].."<"..energy_max[k].."/"..energy_current[k]) end]] update_bar(k) end
  Redraw()
end

function update_bar(type, colour, colour2, colour3, colour4, window)
--  Note("updating bar for "..type)
  local offset = 0
  local height = energybar_height
  local colour = colour or energy_colours[type][1]
  local colour2 = colour2 or energy_colours[type][2]
  local colour3 = colour3 or energy_colours[type][3]
  local colour4 = colour4 or energy_colours[type][4]
  local window = window or energy_windows[type]
  --don't enable this, too spammy
  --Note(colour, colour2, colour3, colour4, window)
  if not colour or not colour2 or not colour3 or not colour4 or not window then return end
    if energy_max[type] > 0 then
      filled = energy_current[type] / energy_max[type]
      filled_prev = energy_prev[type] / energy_max[type]
      percent = energy_current[type]/energy_max[type]*100
    else -- avoid division by zero
      filled = 0
      filled_prev = 0
      percent = 0
    end -- if
    WindowGradient (window, offset, -1, energybar_width+offset, height/2, colourBlack, colour2, 2)
    WindowGradient (window, offset, height/2, energybar_width+offset, height+1, colour2, colourBlack, 2)
    if energy_current[type] > 0 then
      --draw order
      WindowGradient (window, offset, -1, math.ceil(filled*energybar_width), height/2, colourBlack, colour, 2)
      WindowGradient (window, offset, height/2, math.ceil(filled*energybar_width), height+1, colour, colourBlack, 2)
      local left = filled*energybar_width+offset
      local right = filled_prev*energybar_width
      --are we decreasing?
      if right<left then local temp=right right=left left=temp else colour3 = colour4 end
      if math.abs(left-right)>=1 then --prevents silliness
        WindowGradient (window, left, -1, right, height/2, colourBlack, colour3, 2)
        WindowGradient (window, left, height/2, right, height+1, colour3, colourBlack, 2)
      end
      energy_prev[type] = (energy_prev[type]*energybar_update_ratio)+(energy_current[type]*(1-energybar_update_ratio))
    end -- if
    -- write the information inside
    outlined_text (colourGold, window, type, 9, 3+offset, (height-14)/2, 0)
    if (type ~= "Enemy") then
      outlined_text (colourGold, window, energy_current[type]..' / '..energy_max[type], 9, 55+offset, (height-14)/2, 90)
      outlined_text (colourGold, window, math.ceil(percent)..'%', 9, energybar_width-3+offset, (height-14)/2, 0, true)
    else
      outlined_text (colourGold, window, math.ceil(percent)..'%', 9, 55+offset, (height-14)/2, 0)
    end
end

--are we unable to gain xp at the current level?
function max_level (level)
  if level==nil then return false end
  level = tonumber(level)
  return (level==50 or level==75 or level==100)
end

function get_dex(level, isBoss)
  if isBoss then return math.min(15, math.max(0, math.ceil(level*20*1.25+1.25+2))) else return math.min(15, math.max(0, math.ceil(tonumber(msdp["LEVEL"])*20))) end
end

function draw_enemy_window()
  check (WindowDrawImage (enemy_window, "score_background", 0, 0, 0, 0, 1))  -- redraw the background
  local curr = msdp["OPPONENT_HEALTH"] or "0"
  local maxi = msdp["OPPONENT_HEALTH_MAX"] or "0"
  local lev = msdp["OPPONENT_LEVEL"] or "0"
  local name = msdp["OPPONENT_NAME"] or ""
  local fighting = true
  if maxi == "0" then maxi="100" end --setting maxi to 100 fixes some divide-by-zeroes when not fighting
  if name == "" then
    fighting = false
  end
  local text = "nothing"
  local tooltip = "You are not fighting anything."
  if fighting then --or if you wanted to see the bar anyway?
    text = name.." (lvl "..lev..")"
    draw_mini_bar (0x00aaaa, 0x333333, enemy_window, 0, enemy_window_height/2, score_width, enemy_window_height/2, curr, maxi)
    outlined_text (colourGold, enemy_window, tostring(tonumber(curr)/tonumber(maxi)*100).."%", enemy_window_height*3/10, score_width-4, enemy_window_height/2, 0, 1)
    local level = tonumber(msdp["OPPONENT_LEVEL"])
    local dex = msdp["DEX"]
    
    local hit_low = math.max(math.ceil(math.max(level-50, 0)+level/10),0) + 5*(get_dex(level, false)-dex)
    local hit_high = math.max(math.ceil((math.max(level-50, 0)+level/10)*1.43),0) + 5*(get_dex(level, true)-dex)
    local dodge_low = hit_low
    local dodge_high = hit_high
    local block_low = math.max(math.ceil(level/2-50), 0)
    local block_high = math.max(math.ceil(level/2*1.43-50), 0)

    tooltip = "With your dexterity of "..dex..":"
    tooltip = tooltip.."\nTo-hit required to hit at all: "..hit_low.."~"..hit_high.." (normal~boss)"
    tooltip = tooltip.."\nDodge required to dodge at all: "..dodge_low.."~"..dodge_high.." (normal~boss)"
    tooltip = tooltip.."\nBlock required to block at all: "..block_low.."~"..block_high.." (normal~boss)"
  end
  WindowHotspotTooltip(enemy_window, "hs_enemy", tooltip)
  WindowMoveHotspot(enemy_window, "hs_enemy", 0, 0, score_width, enemy_window_height)
  outlined_text (colourSilver, enemy_window, text, enemy_window_height*3/10, 0, 0, score_width)
end

-- fill the score
function draw_score ()

  if msdp["CHARACTER_NAME"] == nil or msdp["LEVEL"] == nil or msdp["CLASS"] == nil then
    return
  end -- if

  -- clear the background
  check (WindowDrawImage (score_window, "score_background", 0, 0, 0, 0, 1))  -- redraw the background

  -- draw the avatar
  --check (WindowDrawImage (score_window, "avatar", 70, 50, 187, 147, 3))  -- draw it
  --draw the time of day
  local t, s
  local success = false
  local draw_text = true
  t, s = process_mud_time(msdp["WORLD_TIME"],msdp["WORLD_SEASON"])
  --draw the time image
  if WindowLoadImage (score_window, "time", GetInfo (66) .. path .. "/time/"..t..".png") == eOK then
    success = true
    draw_text = false
  elseif WindowLoadImage (score_window, "time", GetInfo (66) .. path .. "/time/TimeDefault.png") == eOK then
    success = true
  end    
  if success then
    check (WindowDrawImage (score_window, "time", 1, 1, 33, 33, 3))  -- draw it
  else
    Note( "File '" .. GetInfo (66) .. path .. "/time/TimeDefault.png' is missing.")
  end
  if draw_text then
    outlined_text (colourGold, score_window, t, 6, 1, 1, 32)
  end
  --draw the season image
  success = false
  draw_text = true
  if WindowLoadImage (score_window, "season", GetInfo (66) .. path .. "/time/"..s..".png") == eOK then
    success = true
    draw_text = false
  elseif WindowLoadImage (score_window, "season", GetInfo (66) .. path .. "/time/SeasonDefault.png") == eOK then
    success = true
  end    
  if success then
    check (WindowDrawImage (score_window, "season", score_width-33, 1, score_width-1, 33, 3))  -- draw it
  else
    Note( "File '" .. GetInfo (66) .. path .. "/time/SeasonDefault.png' is missing.")
  end -- if
  if draw_text then
    outlined_text (colourGold, score_window, s, 5, score_width-33, 1, 32)
  end
  
  x_offset = score_width/2
  y_offset = 6
  text_length = outlined_text (colourGold, score_window, msdp["CHARACTER_NAME"], 12, 5, y_offset, score_width-10)

  y_offset = y_offset + 18
  if msdp["EMPIRE_NAME"] ~= nil and msdp["EMPIRE_RANK"] ~= nil then
    --are we in an empire?
    local text
    if msdp["EMPIRE_NAME"] ~= "" and msdp["EMPIRE_RANK"] ~= "" then
      text = '<'..msdp["EMPIRE_RANK"]..' of '..msdp["EMPIRE_NAME"]..'>'
    else
      text = '<Adventurer>'
    end
    outlined_text (colourSilver, score_window, text, 7, 0, y_offset, score_width)
  end -- if
  y_offset = y_offset + 14
  local territory_height = 10
  WindowMoveHotspot(score_window, "hs_terr", 0, y_offset, score_width, y_offset+territory_height+2)
  if msdp["EMPIRE_TERRITORY"] ~= nil and msdp["EMPIRE_TERRITORY_MAX"] ~= nil then
    draw_mini_bar(0xaa00aa, 0x330033, score_window, 0, y_offset, score_width, territory_height/2-1, msdp["EMPIRE_TERRITORY"], msdp["EMPIRE_TERRITORY_MAX"])
  end
  y_offset = y_offset + territory_height/2+1
  if msdp["EMPIRE_TERRITORY_OUTSIDE"] ~= nil and msdp["EMPIRE_TERRITORY_OUTSIDE_MAX"] ~= nil then
    draw_mini_bar(0xaaaaaa, 0x333333, score_window, 0, y_offset, score_width, territory_height/2-1, msdp["EMPIRE_TERRITORY_OUTSIDE"], msdp["EMPIRE_TERRITORY_OUTSIDE_MAX"])
  end
  if msdp["EMPIRE_TERRITORY"] ~= nil and msdp["EMPIRE_TERRITORY_MAX"] ~= nil and msdp["EMPIRE_TERRITORY_OUTSIDE"] ~= nil and msdp["EMPIRE_TERRITORY_OUTSIDE_MAX"] ~= nil then
    local territory = tonumber(msdp["EMPIRE_TERRITORY"])
    local maxterritory = tonumber(msdp["EMPIRE_TERRITORY_MAX"])
    local outside = tonumber(msdp["EMPIRE_TERRITORY_OUTSIDE"])
    local maxoutside = tonumber(msdp["EMPIRE_TERRITORY_OUTSIDE_MAX"])
    local territoryfree = maxterritory-territory
    local outsidefree = maxoutside - outside
    local tooltip = "Total territory: "..territory.."/"..maxterritory.." ("..math.floor(territory/maxterritory*100).."%) - "..territoryfree.." left.\n"
    local tooltip = tooltip.."Outside territory: "..outside.."/"..maxoutside.." ("..math.floor(outside/maxoutside*100).."%) - "..outsidefree.." left."
    WindowHotspotTooltip(score_window, "hs_terr", tooltip)
  end
  y_offset = y_offset + territory_height/2
--  text_line = 'Level '..msdp["LEVEL"]..' '..msdp["RACE"]..' '..msdp["CLASS"]
  WindowMoveHotspot(score_window, "hs_level", 0, y_offset+2, score_width, y_offset+14)
  local lvl = msdp["LEVEL"]
  if msdp["LEVEL"] and msdp["SKILL_LEVEL"] and msdp["GEAR_LEVEL"] and msdp["CRAFTING_LEVEL"] then
    local tooltip = "Combat ["..msdp["LEVEL"].."]: "..msdp["SKILL_LEVEL"].." (skills) + "..msdp["GEAR_LEVEL"].." (gear)\n"
    tooltip = tooltip.."Crafting ["..msdp["CRAFTING_LEVEL"].."]: "..msdp["SKILL_LEVEL"].." (skills) + "..(tonumber(msdp["CRAFTING_LEVEL"])-tonumber(msdp["SKILL_LEVEL"])).." (gear)"
    WindowHotspotTooltip(score_window, "hs_level", tooltip)
    if msdp["CRAFTING_LEVEL"] > msdp["SKILL_LEVEL"] then lvl=lvl.."|"..msdp["CRAFTING_LEVEL"] end
  end
  text_line = 'Level '..lvl..' '..msdp["CLASS"]
  outlined_text (colourGold, score_window, text_line, 10, 5, y_offset, score_width)

  --y_offset = y_offset + 145
    y_offset = y_offset + 80
  if not no_blood then
    y_offset = y_offset + 20
  end
  
  draw_stat = function(stat)
    local fancystat = string.upper(string.sub(stat, 1, 1))..string.lower(string.sub(stat, 2))
    local lowerstat = string.lower(stat)
    outlined_text (colourGold, score_window, fancystat..":", 9, 5, y_offset, 0)
    WindowMoveHotspot(score_window, "hs_"..lowerstat, 0, y_offset, x_offset-40, y_offset+12)
    WindowHotspotTooltip(score_window, "hs_"..lowerstat, "Not working properly.")
    if msdp[stat] ~= nil and msdp[stat.."_PERM"] ~= nil then
      if stat == "STR" then
         WindowHotspotTooltip(score_window, "hs_str", "Min: 1. Base: "..msdp["STR_PERM"]..". Max: 15.\nProviding +"..msdp["STR"].." physical damage.")
      elseif stat == "DEX" then
         WindowHotspotTooltip(score_window, "hs_dex", "Min: 0. Base: "..msdp["DEX_PERM"]..". Max: 15.\nProviding +"..(tonumber(msdp["DEX"])*5).." To-hit & Dodge.")
      elseif stat == "INT" then
         WindowHotspotTooltip(score_window, "hs_int", "Min: 1. Base: "..msdp["INT_PERM"]..". Max: 15.\nProviding +"..msdp["INT"].." magical damage.")
      elseif stat == "WIT" then
         WindowHotspotTooltip(score_window, "hs_wit", "Min: 0. Base: "..msdp["WIT_PERM"]..". Max: 15.\nProviding "..(tonumber(msdp["WIT"])*0.025*100).."% faster attack speed.")
      elseif stat == "CHA" then
         WindowHotspotTooltip(score_window, "hs_cha", "Min: 1. Base: "..msdp["CHA_PERM"]..". Max: 15.")
      elseif stat == "GRT" then
         WindowHotspotTooltip(score_window, "hs_grt", "Min: 0. Base: "..msdp["GRT_PERM"]..". Max: 15.\nProviding +"..(tonumber(msdp["GRT"])*35).." territory.")
      end
      colour = colourSilver
      --convert to numbers to allow comparison
      st = tonumber(msdp[stat])
      st_perm = tonumber(msdp[stat.."_PERM"])
      if st<st_perm then colour = colourRed elseif st>st_perm then colour = colourGreen end
      outlined_text (colour, score_window, msdp[stat], 9, 70, y_offset, 0, true)
    end -- if
  end
  

  draw_stat("STR")

  outlined_text (colourGold, score_window, "To-hit:", 9, x_offset, y_offset, 0)
  WindowMoveHotspot(score_window, "hs_tohit", x_offset, y_offset, score_width-40, y_offset+12)
  if msdp["TO_HIT"] ~= nil then
    if msdp["LEVEL"] ~= nil and msdp["DEX"] ~= nil and msdp["DODGE"] ~= nil then
      --calculate fun stats
      local tohit_self = math.min(100, math.max(5, tonumber(msdp["TO_HIT"])-tonumber(msdp["DODGE"])))
      local trash_dodge = math.ceil(math.max(0, tonumber(msdp["LEVEL"]) - 50) + (tonumber(msdp["LEVEL"]) * 0.1))
      local trash_dex = math.min(15, math.max(0, math.ceil(tonumber(msdp["LEVEL"])*20)))
      local tohit_trash = math.min(100, math.max(5, 5*(trash_dex-tonumber(msdp["DEX"]))+(tonumber(msdp["TO_HIT"])-trash_dodge)))
      local boss_dodge = math.ceil((math.max(0, tonumber(msdp["LEVEL"]) - 50) + (tonumber(msdp["LEVEL"]) * 0.1))*1.43)
      local boss_dex = math.min(15, math.max(0, math.ceil(msdp["LEVEL"]*20*1.25+1.25+2)))
      local tohit_boss = math.min(100, math.max(5, 5*(boss_dex-tonumber(msdp["DEX"]))+(tonumber(msdp["TO_HIT"])-boss_dodge)))
      WindowHotspotTooltip(score_window, "hs_tohit", "Chance to hit yourself: "..tohit_self.."%\nChance to hit trash (your level): "..tohit_trash.."%\nChance to hit boss (your level): "..tohit_boss.."%")
    end
    outlined_text (colourSilver, score_window, msdp["TO_HIT"], 9, 65+x_offset, y_offset, 0)
  end -- if

  y_offset = y_offset + 20
  
  draw_stat("DEX")

  outlined_text (colourGold, score_window, "Dodge:", 9, x_offset, y_offset, 0)
  WindowMoveHotspot(score_window, "hs_dodge", x_offset, y_offset, score_width-40, y_offset+12)
  if msdp["DODGE"] ~= nil then
    if msdp["LEVEL"] ~= nil and msdp["DEX"] ~= nil and msdp["TO_HIT"] ~= nil then
      --calculate fun stats
      local tododge_self = math.min(95, math.max(0, tonumber(msdp["DODGE"])-tonumber(msdp["TO_HIT"])+100))
      local trash_tohit = math.ceil(math.max(0, tonumber(msdp["LEVEL"]) - 50) + (tonumber(msdp["LEVEL"]) * 0.1))-50
      local trash_dex = get_dex(msdp["LEVEL"], false)
      local tododge_trash = math.min(75, math.max(0, 5*(trash_dex-tonumber(msdp["DEX"]))+(tonumber(msdp["DODGE"])-trash_tohit)))
      local boss_tohit = math.ceil((math.max(0, tonumber(msdp["LEVEL"]) - 50) + (tonumber(msdp["LEVEL"]) * 0.1))*1.43)-50
      local boss_dex = get_dex(msdp["LEVEL"], true)
      local tododge_boss = math.min(75, math.max(0, 5*(boss_dex-tonumber(msdp["DEX"]))+(tonumber(msdp["DODGE"])-boss_tohit)))
      WindowHotspotTooltip(score_window, "hs_dodge", "Chance to dodge yourself: "..tododge_self.."%\nChance to dodge trash (your level): "..tododge_trash.."%\nChance to dodge boss (your level): "..tododge_boss.."%")
    end
    outlined_text (colourSilver, score_window, msdp["DODGE"], 9, 65+x_offset, y_offset, 0)
  end -- if

  y_offset = y_offset + 20
  draw_stat("INT")

  outlined_text (colourGold, score_window, "Block:", 9, x_offset, y_offset, 0)
  WindowMoveHotspot(score_window, "hs_block", x_offset, y_offset, score_width-40, y_offset+12)
  if msdp["BLOCK"] ~= nil then
    if msdp["LEVEL"] ~= nil then
      --calculate fun stats
      local target_trash = (tonumber(msdp["LEVEL"])/2)-50
      local toblock_trash = math.max(0, math.min(tonumber(msdp["BLOCK"] - target_trash), 50))
      local target_boss = (tonumber(msdp["LEVEL"])/2*1.43)-50
      local toblock_boss = math.max(0, math.min(tonumber(msdp["BLOCK"] - target_boss), 50))
      WindowHotspotTooltip(score_window, "hs_block", "Chance to block trash (your level): "..toblock_trash.."%\nChance to block boss (your level): "..toblock_boss.."%")
    end
    outlined_text (colourSilver, score_window, msdp["BLOCK"], 9, 65+x_offset, y_offset, 0)
  end -- if

  y_offset = y_offset + 20
  draw_stat("WIT")
  
  outlined_text (colourGold, score_window, "Resist: ", 9, x_offset, y_offset, 0)
  WindowMoveHotspot(score_window, "hs_resist", x_offset, y_offset, score_width-40, y_offset+12)
  if msdp["RESIST_PHYSICAL"] ~= nil and msdp["RESIST_MAGICAL"] ~= nil then
    if msdp["LEVEL"] ~= nil then
      --calculate fun stats
      local max_resist = tonumber(msdp["LEVEL"])/2
      local phys = tonumber(msdp["RESIST_PHYSICAL"])
      local magic = tonumber(msdp["RESIST_MAGICAL"])
      local resisted_p = 0
      local resisted_m = 0
      if tonumber(phys)>max_resist/2 then
        local use_resist = math.min(max_resist, phys)
        resisted_p = ((use_resist - (max_resist/2.0)) / (max_resist / 2.0))/4
      end
      if tonumber(magic)>max_resist/2 then
        local use_resist = math.min(max_resist, magic)
        resisted_m = ((use_resist - (max_resist/2.0)) / (max_resist / 2.0))/4
      end
      WindowHotspotTooltip(score_window, "hs_resist", "Physical resistance (at your level): "..(resisted_p*100).."%\nMagical resistance (at your level): "..(resisted_m*100).."%")
    end
    outlined_text (colourSilver, score_window, msdp["RESIST_PHYSICAL"]..'|'..msdp["RESIST_MAGICAL"], 9, 65+x_offset, y_offset, 0)
  end -- if

  y_offset = y_offset + 20
  outlined_text (colourGold, score_window, "Cha:", 9, 5, y_offset, 0)
  WindowMoveHotspot(score_window, "hs_cha", 0, y_offset, x_offset-40, y_offset+12)
  draw_stat("CHA")

  outlined_text (colourGold, score_window, "+", 9, x_offset-15, y_offset, 0)
  outlined_text (colourGold, score_window, "Phys:", 9, x_offset, y_offset, 0)
  outlined_text (colourGold, score_window, "Magic:", 9, x_offset, y_offset, (score_width-5)-x_offset)
  outlined_text (colourGold, score_window, "Heal:", 9, score_width-3, y_offset, 0, true)
  if msdp["BONUS_PHYSICAL"] ~= nil and msdp["BONUS_MAGICAL"] ~= nil and msdp["BONUS_HEALING"] ~= nil then
    --outlined_text (colourSilver, score_window, msdp["BONUS_PHYSICAL"]..'p '..msdp["BONUS_MAGICAL"]..'m '..msdp["BONUS_HEALING"]..'h', 9, x_offset, 20+y_offset, 0)
    WindowMoveHotspot(score_window, "hs_phys", x_offset, y_offset, (score_width+x_offset*2)/3, y_offset+32)
    outlined_text (colourSilver, score_window, msdp["BONUS_PHYSICAL"], 9, x_offset+5, 20+y_offset, 0)
    WindowMoveHotspot(score_window, "hs_magic", (score_width+x_offset*2)/3, y_offset, (score_width*2+x_offset)/3, y_offset+32)
    outlined_text (colourSilver, score_window, msdp["BONUS_MAGICAL"], 9, x_offset, 20+y_offset, (score_width-5)-x_offset)
    WindowMoveHotspot(score_window, "hs_heal", (score_width*2+x_offset)/3, y_offset, score_width, y_offset+32)
    outlined_text (colourSilver, score_window, msdp["BONUS_HEALING"], 9, score_width-8, 20+y_offset, 0, true)
  end -- if
  
  y_offset = y_offset + 20
  draw_stat("GRT")
  
  y_offset = y_offset + 20
  
  colourNormal1 = 0x00AAAA
  colourNormal2 = 0x003333
  colourMax1 = 0x00AA00
  colourMax2 = 0x003300
  colourBad1 = 0x0000AA
  colourBad2 = 0x000033
  if msdp["BONUS_EXP"] and tonumber(msdp["BONUS_EXP"]) > 0 then
    local size = 10
    draw_mini_bar (0x888800, 0x333300, score_window, (score_width-xpbar_width)/2, y_offset, xpbar_width, size, msdp["BONUS_EXP"], 15)
    if tonumber(msdp["BONUS_EXP"])>15 then
      draw_mini_bar (0xFFFF00, 0xAAAA00, score_window, (score_width-xpbar_width)/2, y_offset, xpbar_width, size, tonumber(msdp["BONUS_EXP"])-15, 15)
    end
    outlined_text (colourSilver, score_window, msdp["BONUS_EXP"], size-4, 27, y_offset-(size-10)/2, 0, true)    
    outlined_text (colourSilver, score_window, "Bonus experience points", size-4, 33, y_offset-(size-10)/2, 0)
    outlined_text (colourSilver, score_window, math.ceil(tonumber(msdp["BONUS_EXP"]/15)*100-0.5).."%", size-4, score_width-3, y_offset-(size-10)/2, 0, true)
    --draw_xp_bar ("Bonus experience", 0xAAAA00, 0x333300, score_window, (score_width-xpbar_width)/2, y_offset, msdp["BONUS_EXP"], 15, msdp["BONUS_EXP"])
    y_offset = y_offset + size+2
  end
  local spacing = xpbar_height+2 + 0
  local skills = {}
  local name
  local data
  local skill_data = unpack_array(msdp["SKILLS"])
  local hotspots = WindowHotspotList(score_window)
  local hotspots_skills = {}
  if hotspots then
    for _,v in ipairs (hotspots) do 
      if string.sub(v,1,string.len(skill_hotspot_prefix)) == skill_hotspot_prefix then
        table.insert(hotspots_skills, v)
      end
    end
  end
  if skill_data ~= nil then
    local a = {}
    for n in pairs(skill_data) do table.insert(a, n) end
    table.sort(a) --this hack sorts skills alphabetically
    for _,name in ipairs(a) do
      local data = skill_data[name]
      table.insert(skills, name)
      --debug info
      --if data ~= nil then for k,v in pairs(data) do Note(k..": "..v) end else Note("no skill data for "..sk) end
      --draw skill:
      if data ~= nil and data["EXP"] ~= nil and data["LEVEL"] ~= nil then
        if tonumber(data["LEVEL"])>0 or tonumber(data["EXP"])>0 then
          if max_level(data["LEVEL"]) then colour = colourMax1 colour2 = colourMax2 elseif data["NOSKILL"]=="1" then colour = colourBad1 colour2 = colourBad2 else colour = colourNormal1 colour2 = colourNormal2 end
          draw_xp_bar (name, colour, colour2, score_window, (score_width-xpbar_width)/2, y_offset, data["EXP"], 100, data["LEVEL"])
          local found = false
          --find the hotspot
          for _,v in ipairs(hotspots_skills) do
            if string.lower(v)==string.lower(skill_hotspot_prefix)..string.lower(name) then found = true break end
          end
          --move it into place, or create it if not found
          if not found then
--            Note("Adding new tooltip "..skill_hotspot_prefix..string.lower(name))
            WindowAddHotspot(score_window, skill_hotspot_prefix..string.lower(name), (score_width-xpbar_width)/2, y_offset-1, (score_width-xpbar_width)/2+xpbar_width, y_offset+spacing-1, "", "", "", "", "", name, 12, 0);
          else
            WindowMoveHotspot(score_window, skill_hotspot_prefix..string.lower(name), (score_width-xpbar_width)/2, y_offset-1, (score_width-xpbar_width)/2+xpbar_width, y_offset+spacing-1)
          end
          --set the tooltip
          local noskilled = ""
          if data["NOSKILL"] == "1" then
            noskilled = "\nSkill gains disabled (noskill)."
          end
          local resets = "No skill resets available."
          if data["RESETS"] ~= nil and tonumber(data["RESETS"]) > 0 then
            resets = "Skill resets available: "..data["RESETS"].."."
          end
          local xp = ""
          if max_level(data["LEVEL"]) then
            xp = " (max level)."
          else
            xp = " with "..data["EXP"].."% chance to gain."
          end
          WindowHotspotTooltip(score_window, skill_hotspot_prefix..string.lower(name), name..": Level "..data["LEVEL"]..xp.."\n"..resets..noskilled)
          y_offset = y_offset + spacing
        end
      else
        --No specific skill data
      end
    end
    --Remove old skill hotspots
    for _,spot in ipairs(hotspots_skills) do
      local found
      for _,skill in ipairs(skills) do
        if string.find(string.lower(spot), string.lower(skill)) then
          found = true
        end
      end
      if not found then WindowDeleteHotspot(score_window, spot) end
    end
  end
  
  right = GetInfo (281) + right_offset
  bottom = GetInfo (280) + bottom_offset
  local inset = 4
  draw_cooldowns(score_left+inset, top+y_offset+11+inset)--(right+34, top+y_offset+11)

end -- draw_score

--Deprecated:
function split_nested_arrays (msdp_data)
  --This just unsticks nestedarrays, like DOTS, from each other, and returns them as an array of strings
  --It won't help if there's nested arrays in the nested arrays
  --The full data looks like:
  --\1DOTS\2\3<\1[dotname]\2\3\1DURATION\2[value]\1TYPE\2[value]\1DAMAGE\2[value]\1STACKS\2[value]\4>*?\4
  --msdp_data is <\1[dotname]\2\3\1DURATION\2[value]\1TYPE\2[value]\1DAMAGE\2[value]\1STACKS\2[value]\4>*?
  --I'm not sure this is necessary any more
  local data = {}
  local index = 1
  local depth = 0
  local start = 1
  for position = 1, string.len(msdp_data) do
    local char = string.sub(msdp_data, position, position)
    if char == '\001' then
      --start of a new value, but we actually handle this in the \004 case
    end
    if char == '\003' then
      depth = depth + 1
    elseif char == '\004' then
      depth = depth - 1
      if depth == 0 then
        data[index] = string.sub(msdp_data, start, position)
        index = index + 1
        start = position + 1
      end
    end
  end
  return data
end

function filter(input) --turns specific telnet codes into a more visually appealing[?] format - debug use only
  input = string.gsub(input,"\1","|")
  input = string.gsub(input,"\2","=")
  input = string.gsub(input,"\3","{")
  input = string.gsub(input,"\4","}")
  return input
end

function unpack_array(msdp_data)
  --Unpack an array of the form \1VAR_NAME\2VAR_VALUE\1VAR_NAME\2VAR_VALUE etc. by calling itself recursively.
  --This is necessary for affects, cooldowns, room data, etc.
  --Assumes the leading \1NAME\2\3 and trailing \4 are already gone but (hopefully) doesn't rely on it
  --\1NAME\2VALUE will return {NAME, VALUE}
  --\1NAME\2\3\1NAME\2VALUE\4 will return {NAME, {NAME, VALUE}}
  --\1NAME\2\3\1NAME\2\3\1PROPERTY\2VALUE\4\4 will return {NAME, {NAME, {PROPERTY, VALUE}}}
  --At least I think so, pretty sure I wrote this before the actual function
  if msdp_data == nil then return nil end
  if msdp_data == "" then return {} end
  if string.sub(msdp_data, 1, 1) ~= "\1" then
    msdp_data = "\1"..msdp_data --this should be here in the first place, it's what bIgnore removes
    --but affects assumes it's not
  end
  local position = 1
  local data = {}
  local str = ""
  local is_key = false
  local is_value = false
  local key = ""
  local value = ""
  local depth = 0
  local add = false
  local enable_debug = false
  local char = ""
  if enable_debug then Note(filter(msdp_data)) end
  while position<=string.len(msdp_data) do
    char = string.sub(msdp_data, position, position)
    if (char == '\1' or (position==string.len(msdp_data) and is_value)) and depth==0 then
      if enable_debug then Note("Hit 1. End of: "..str) end
      if position==string.len(msdp_data) then str = str..char if enable_debug then Note("Hit end of string.") end end
      if is_value then
        value = str
        if key ~= "" and value ~= "" then
            add = true
        end
      elseif is_value then --two keys in a row...?
         --ignore
      end
      str = ""
      is_value = false
      is_key = true
    elseif (char == '\2' or (position==string.len(msdp_data) and is_key)) and depth==0 then
      if enable_debug and char == '\2' then Note("Hit 2. End of: "..str) end
      if position==string.len(msdp_data) then str = str..char if enable_debug then Note("Hit end of string.") end end
      if is_key then
        key = str
        if key ~= "" and value ~= "" then
            add = true
        end
      elseif is_value then --two values in a row...?
        --ignore for now
      end
      str = ""
      is_key = false
      is_value = true
    elseif char == '\3' then
      if enable_debug then Note("Hit 3.") end
      depth = depth + 1 --sigh
    elseif char == '\4' then
      if enable_debug then Note("Hit 4.") end
      depth = depth - 1 --whew
      if depth == 0 then
        if is_value then
          if str == "" then value = {} else value = unpack_array(str) end --if we get an empty array (room has no exits)
          if key ~= "" and value ~= "" then
            add = true
          end
        end
      end
      str = ""
    else
      --if is_key and enable_debug then Tell("k") elseif is_value and enable_debug then Tell("v") end
      str = str..char
    end
      
    if add then
      if type(value) == "string" then
        if enable_debug then Note("Added "..key..":"..value) end
      else
        if enable_debug then Note("Added "..key..": not string") end
      end
      if data[key] ~= nil then --stops same-named fields from overwriting: common with script dots
        for disamb = 1, 256 do
          if data[key.." ("..disamb..")"] == nil then
            key = key .." ("..disamb..")"
            break
          end
        end
      end
      data[key] = value
      key = ""
      value = ""
      add = false
    end
    position = position + 1
  end
  --debug:
  if enable_debug then
    for k, v in pairs(data) do
      if type(v) == "table" then
        for u, i in pairs(v) do
          Note(k..": {u:"..u..",i:"..i.."}")
        end
      else
        Note(k..":"..v)
      end
    end
  end
  return data
end

local AffectName = {}
local AffectDuration = {}
local AffectMax = 0

function init_affects (data)

  index = 0
  startpos = 1
  local max = 0
  for i=startpos,string.len(data),1 do
    if string.byte(data,i) == 1 or i == string.len(data) then
      if string.byte(data,i) == 1 then
        endpos = 1
      else
        endpos = 0
      end -- if
      variable = string.sub(data,startpos,i-endpos)
      startpos = i+1
      index = index + 1

      pos1 = string.find(variable, "\002")
      if pos1 ~= nil then
        AffectName[index] = string.sub(variable, 1, pos1-1)
        AffectDuration[index] = string.sub(variable, pos1+1)
      end -- if
    end -- if
  end -- for

  -- AffectMax is the highest EVER number - we need to keep track of all created icons
  if index < AffectMax then
    for i=index+1,AffectMax,1 do
      AffectName[i] = nil
      win = affect_window_prefix..i
      WindowShow (win, false)
    end -- for
    AffectMax = index
  elseif index > AffectMax then
    AffectMax = index
  end -- if
end --function



local CooldownName = {}
local CooldownDuration = {}
local CooldownMode = {}
local CooldownMax = 0
  
function init_cooldowns (data)

  index = 0
  startpos = 1
  local max = 0
  for i=startpos,string.len(data),1 do
    if string.byte(data,i) == 1 or i == string.len(data) then
      if string.byte(data,i) == 1 then
        endpos = 1
      else
        endpos = 0
      end -- if
      variable = string.sub(data,startpos,i-endpos)
      startpos = i+1
      index = index + 1

      pos1 = string.find(variable, "\002")
      if pos1 ~= nil then
        CooldownName[index] = string.sub(variable, 1, pos1-1)
        CooldownDuration[index] = string.sub(variable, pos1+1)
      end -- if
    end -- if
  end -- for

  -- CooldownMax is the highest EVER number - we need to keep track of all created icons
  if index < CooldownMax then
    for i=index+1,CooldownMax,1 do
      CooldownName[i] = nil
      win = cooldown_window_prefix..i
      WindowShow (win, false)
    end -- for
    CooldownMax = index
  elseif index > CooldownMax then
    CooldownMax = index
  end -- if  
  --debug
  --AddCooldown("ability1","64")
  --AddCooldown("ability2","128")    
  --AddCooldown("ability3","32")
  --AddCooldown("lightningbolt","9")
  --AddCooldown("sunshock","9")
  --AddCooldown("kick","6")
  --AddCooldown("not-alternate","60")
end -- function

function AddCooldown(name, dur) --debug purposes only! bugs out a lot
  table.insert(CooldownName, name)
  table.insert(CooldownDuration, dur)
  CooldownMax = CooldownMax + 1
end

function seconds_to_minutes (seconds)
  minutes = math.floor(seconds/60)
  seconds = seconds-minutes*60
  if minutes>0 then
    if seconds<10 then seconds = "0"..seconds end --:0 becomes :00
    return minutes..":"..seconds
  else
    return seconds
  end
end

function compare(a,b) --for sort_cooldowns
  return a[2] < b[2]
end

function sort_cooldowns ()
  --turns CooldownName and CooldownDuration into a two-dimensional array, sorts it, then puts them back
  --This seems ridiculous but nothing else was working
  local t = {}
  local i = 1
  for i = 1, CooldownMax do
    --I have no idea why this was happening but it's causing a lot of errors
    if CooldownName[i] == nil then return end
    if CooldownDuration[i] == nil then return end
    t[i] = {CooldownName[i], tonumber(CooldownDuration[i])}
--    Note(CooldownName[i]..":"..CooldownDuration[i])
  end
  table.sort(t, compare)
  for k, v in pairs(t) do
    CooldownName[k] = v[1]
    CooldownDuration[k] = v[2]
  end
end

function AffectMouseUp(flags, hotspot_id)
  if bit.band (flags, 0x10) ~= 0 then
    -- must be left mouse
    affect_click(hotspot_id)
  end -- if
end

function affect_mode_switch(mode)
  return not mode
end

function affect_click(hotspot_id)
  local len = string.len(affect_window_prefix)
  local id = 0
  if string.sub(hotspot_id, 1, len) == affect_window_prefix then
    id = tonumber(string.sub(hotspot_id, len+1))
    AffectMode[id] = affect_mode_switch(AffectMode[i])
  end
  local len = string.len(cooldown_window_prefix)
  if string.sub(hotspot_id, 1, len) == cooldown_window_prefix then
    id = tonumber(string.sub(hotspot_id, len+1))
    CooldownMode[id] = affect_mode_switch(CooldownMode[i])
  end
end

local dot_max = 0
local dots = {}

function draw_dots (startx, starty)
  dots = unpack_array(msdp["DOTS"])
  for i=1,dot_max,1 do
    WindowShow (dot_window_prefix..i, false)
  end -- for
  if dots == nil or dots == "None" or dots == {} then
    dot_max = 0
    return
  end -- if
  offset_x = 0
  offset_y = 0
  local i = 0
  for k,v in pairs(dots) do
--    Note(k)
    i = i + 1
    if k ~= nil then
      win = dot_window_prefix..i
      dot = "dot_"..i
      if v["STACKS"]==nil then Note("Stacks is nil for dot "..k) v["STACKS"]="1" end
      -- draw the icons left to right, top to bottom
      if i > 1 then
--[[        if offset_x == 0 then
          offset_x = 36
        elseif offset_x == 36 then
          offset_x = 72
        elseif offset_x == 72 then
          offset_x = 108
        else
          offset_x = 0]]
          offset_y = offset_y + 36
 --       end -- if
      end -- if

      colour = colourGold

      -- make a miniwindow under the text
      check (WindowCreate (win,   -- window ID
                    startx+offset_x,  -- left, GetInfo(281)-320-39
                    starty+offset_y, -- top, 73
                    34,           -- width
                    34,           -- depth
                    12,           -- center it (ignored anyway) 
                    2,            -- draw underneath (1) + absolute location (2)
                    colourBlack))      -- background colour
      WindowSetZOrder (win, 21)
      -- load the icon
      if WindowLoadImage (win, dot, GetInfo (66) .. path .. "/affects/" .. k .. ".png") == eOK then
        check (WindowDrawImage (win, dot, 1, 1, 33, 33, 2))  -- exact name
      elseif WindowLoadImage (win, dot, GetInfo (66) .. path .. "/affects/" .. v["TYPE"] .. ".png") == eOK then
        check (WindowDrawImage (win, dot, 1, 1, 33, 33, 2))  -- type (physical, poison etc.)
      elseif WindowLoadImage (win, dot, GetInfo (66) .. path .. "/affects/default.png") == eOK then
        check (WindowDrawImage (win, dot, 1, 1, 33, 33, 2))  -- draw the default affect icon instead
      else -- even the default spell icon is missing
        Note( "Missing spell icons.")
        return
      end -- if
      
      if tonumber(v["DURATION"]) < 10 then --1 digit
        offset = 18
      elseif tonumber(v["DURATION"]) < 60 then --2 digits
        offset = 22
      elseif tonumber(v["DURATION"]) < 600 then --3 digits
        offset = 26
      else -- 4 digits
        offset = 30
      end -- if

      if tonumber(v["DURATION"]) < 0 then
        -- draw an infinity symbol
        local start_x = 20
        outlined_text (colour, win, "O", 6, start_x, 21, 0)
        outlined_text (colour, win, "O", 6, start_x+5, 21, 0)
        -- go over the first 'O' again, removing the outline from the second 'O'
        WindowFont(win,'f',font,6,1,0,0,0)
        WindowText(win,'f',"O",start_x,21,0,0,colour,0)
      else -- write the duration
        outlined_text (colour, win, seconds_to_minutes(tonumber(v["DURATION"])), 6, offset, 21, 0, true) --4->32
      end -- if
      if tonumber(v["STACKS"])>0 then
        outlined_text (colour, win, "x"..v["STACKS"], 6, 3, 3, 0)
      end
      -- show the window
      if gui_on then
        WindowShow (win, true)
      end

      -- create a hotspot over the timer
      local tooltip = k.."("..v["TYPE"]..")\n"..v["DAMAGE"].." damage ("..(tonumber(v["DAMAGE"])/5).." per second)."
      WindowAddHotspot(win, "hs_dot_"..i, 0, 0, 34, 34, "", "", "", "", "AffectMouseUp", tooltip, 1, 0)
    end -- if
  end -- for
  if i>dot_max then dot_max = i end
end --function


function draw_cooldowns (startx, starty)
  cooldowns = msdp["COOLDOWNS"]
  --test:
  if cooldowns == nil or cooldowns == "None" then
    for i=1,CooldownMax,1 do
      WindowShow (cooldown_window_prefix..i, false)
    end -- for
    CooldownMax = 0
    return
  end -- if

  init_cooldowns (cooldowns)
--[[  CooldownMax = 3
  CooldownName[1] = "lightningbolt"
  CooldownDuration[1] = 9
  CooldownName[2] = "summon swift"
  CooldownDuration[2] = 60
  CooldownName[3] = "skybrand"
  CooldownDuration[3] = 6]]
  if CooldownMax > 1 then
    sort_cooldowns ()
  end

  offset_x = 0
  offset_y = 0

  for i=1,CooldownMax,1 do
    if CooldownName[i] ~= nil then
      win = cooldown_window_prefix..i
      cooldown = "cooldown_"..i

      -- draw the icons left to right, top to bottom
      local column_width = 36
      local row_height = 36
      local columns = 6
      if i > 1 then
        if offset_x == 0 then
          offset_x = column_width
        elseif offset_x < columns * column_width then
          offset_x = offset_x + column_width
        else
          offset_x = 0    
          offset_y = offset_y + row_height
        end -- if
      end -- if

      colour = colourGold

      -- make a miniwindow under the text
      check (WindowCreate (win,   -- window ID
                    startx+offset_x,  -- left, GetInfo(281)-320-39
                    starty+offset_y, -- top, 73
                    34,           -- width
                    34,           -- depth
                    12,           -- center it (ignored anyway) 
                    2,            -- draw underneath (1) + absolute location (2)
                    colourBlack))      -- background colour
      WindowSetZOrder (win, 21)
      -- load the icon
      if WindowLoadImage (win, cooldown, GetInfo (66) .. path .. "/cooldowns/" .. CooldownName[i] .. ".png") == eOK then
        check (WindowDrawImage (win, cooldown, 1, 1, 33, 33, 2))  -- draw the icon
      elseif WindowLoadImage (win, cooldown, GetInfo (66) .. path .. "/cooldowns/default.png") == eOK then
        check (WindowDrawImage (win, cooldown, 1, 1, 33, 33, 2))  -- draw the default icon instead
      else -- even the default spell icon is missing
        Note( "Missing spell icons.")
        return
      end -- if
      
      if tonumber(CooldownDuration[i]) < 10 then --1 digit
        offset = 18
      elseif tonumber(CooldownDuration[i]) < 60 then --2 digits
        offset = 22
      elseif tonumber(CooldownDuration[i]) < 600 then --3 digits
        offset = 26
      else -- 4 digits
        offset = 30
      end -- if

      if tonumber(CooldownDuration[i]) < 0 then
        -- draw an infinity symbol
        local start_x = 20
        outlined_text (colour, win, "O", 6, start_x, 21, 0)
        outlined_text (colour, win, "O", 6, start_x+5, 21, 0)
        -- go over the first 'O' again, removing the outline from the second 'O'
        WindowFont(win,'f',font,6,1,0,0,0)
        WindowText(win,'f',"O",start_x,21,0,0,colour,0)
      else -- write the duration
        outlined_text (colour, win, seconds_to_minutes(tonumber(CooldownDuration[i])), 6, offset, 21, 0, true) --4->32
      end -- if

      -- show the window
      if gui_on then
        WindowShow (win, true)
      end

      -- create a hotspot over the timer
      WindowAddHotspot(win, "hs_cooldown_"..i, 0, 0, 34, 34, "", "", "", "", "AffectMouseUp", CooldownName[i], 1, 0)
    end -- if
  end -- for
end --function

function draw_affects ()
  --Affect draw location; dots also use this
  local base_pos_x = right-11+1--GetInfo(281)-320-5
  local base_pos_y = top+11 --73+10
  affects = msdp["AFFECTS"]
  if affects == nil or affects == "None" then
    for i=1,AffectMax,1 do
      WindowShow (affect_window_prefix..i, false)
    end -- for
    AffectMax = 0
    draw_dots(base_pos_x, base_pos_y)
    return
  end -- if


  init_affects (affects)
  --TEST, TEMP
  --[[AffectMax = 2
  AffectName[1] = "sanctuary"
  AffectDuration[1] = "-1"
  AffectName[2] = "hasten"
  AffectDuration[2] = "300"--]]
  offset_x = 0
  offset_y = 0
  local spacing = 36
  for i=1,AffectMax,1 do
    if AffectName[i] ~= nil then
      win = affect_window_prefix..i
      affect = "affect_"..i

      -- draw the icons left to right, top to bottom
      if i > 1 then
        if offset_x == 0 then
--[[
          offset_x = spacing
        elseif offset_x == spacing then
          offset_x = spacing*2
        elseif offset_x == spacing*2 then
          offset_x = spacing*3
        else
          offset_x = 0
--]]
          offset_y = offset_y + spacing
        end -- if
      end -- if

      colour = colourGold

      -- make a miniwindow under the text
      check (WindowCreate (win,   -- window ID
                    base_pos_x+offset_x,  -- left, 14
                    base_pos_y+offset_y, -- top, 383
                    34,           -- width
                    34,           -- depth
                    12,           -- center it (ignored anyway) 
                    2,            -- draw underneath (1) + absolute location (2)
                    colourBlack))      -- background colour
      WindowSetZOrder (win, 21)
      -- load the icon
      if WindowLoadImage (win, affect, GetInfo (66) .. path .. "/affects/" .. AffectName[i] .. ".png") == eOK then
        check (WindowDrawImage (win, affect, 1, 1, 33, 33, 2))  -- draw the icon
      elseif WindowLoadImage (win, affect, GetInfo (66) .. path .. "/affects/default.png") == eOK then
        check (WindowDrawImage (win, affect, 1, 1, 33, 33, 2))  -- draw the default icon instead
      else -- even the default spell icon is missing
        Note( "Missing spell icons.")
        return
      end -- if

      if tonumber(AffectDuration[i]) < 10 then
        offset = 18
      elseif tonumber(AffectDuration[i]) < 60 then
        offset = 15
      else -- 3 digits
        offset = 0
      end -- if

      if tonumber(AffectDuration[i]) < 0 then
        -- draw an infinity symbol
        local start_x = 20
        outlined_text (colour, win, "O", 6, start_x, 21, 0)
        outlined_text (colour, win, "O", 6, start_x+5, 21, 0)
        -- go over the first 'O' again, removing the outline from the second 'O'
        WindowFont(win,'f',font,6,1,0,0,0)
        WindowText(win,'f',"O",start_x,21,0,0,colour,0)
      else -- write the duration
        outlined_text (colour, win, seconds_to_minutes(tonumber(AffectDuration[i])), 6, 32, 21, 0, true) --4->32
      end -- if

      -- show the window
      if gui_on then
        WindowShow (win, true)
      end

      -- create a hotspot over the timer
      WindowAddHotspot(win, "hs_affect_"..i, 0, 0, 34, 34, "", "", "", "", "", AffectName[i], 1, 0)
    end -- if
  end -- for
  if AffectMax > 0 then offset_y = offset_y + spacing end
  draw_dots(base_pos_x, base_pos_y + offset_y)
end -- draw_affects


function outlined_text (colour, window, text, size, x, y, centre_width, rj)
  if rj == nil then rj = false end
  outlineColour = colourBlack

  -- write the information inside
  WindowFont(window,'f',font,size,1,0,0,0)
  if rj then
    if centre_width > 0 then
      --right justify within the box
      width = WindowTextWidth (window, 'f', text)
      x = x + centre_width-width
    else
      --right justify in general
      width = WindowTextWidth (window, 'f', text)
      x = x - width
    end
  elseif centre_width > 0 then
    width = WindowTextWidth (window, 'f', text)
    x = x + ((centre_width-width) / 2)
  end -- if

  -- smear black text around the location to create an outline, so that it's clearer to read
  WindowText(window,'f',text,x+1,y+1,0,0,outlineColour,0)
  WindowText(window,'f',text,x+1,y,0,0,outlineColour,0)
  WindowText(window,'f',text,x+1,y-1,0,0,outlineColour,0)
  WindowText(window,'f',text,x,y+1,y,0,outlineColour,0)
  WindowText(window,'f',text,x,y-1,y,0,outlineColour,0)
  WindowText(window,'f',text,x-1,y+1,0,0,outlineColour,0)
  WindowText(window,'f',text,x-1,y,0,0,outlineColour,0)
  WindowText(window,'f',text,x-1,y-1,0,0,outlineColour,0)

  -- display the text
  WindowText(window,'f',text,x,y,0,0,colour,0)

  return width
end -- outlined_text


-- MSDP negotiation
local MSDP = 69

function OnPluginTelnetRequest (neg_type, data)
  if neg_type == MSDP and data == "WILL" then
    using_msdp = true
    return true
  elseif neg_type == MSDP and data == "SENT_DO" then
    -- IAC SB MSDP response IAC SE 
    -- Split up for readability...
    Basic = "\2CHARACTER_NAME\2CLASS\2LEVEL\2SKILL_LEVEL\2GEAR_LEVEL\2CRAFTING_LEVEL\2BONUS_EXP\2ROOM\2AFFECTS\2COOLDOWNS\2DOTS" --name class level exits affects
    Primary = "\2STR\2INT\2WIT\2DEX\2CHA\2GRT\2STR_PERM\2INT_PERM\2WIT_PERM\2DEX_PERM\2CHA_PERM\2GRT_PERM" --6 primary stats
    Secondary = "\2TO_HIT\2DODGE\2BLOCK\2RESIST_PHYSICAL\2RESIST_MAGICAL\2BONUS_PHYSICAL\2BONUS_MAGICAL\2BONUS_HEALING" --the secondary stats
    --[[local sk = {"BATTLE","EMPIRE","HIGH_SORCERY","NATURAL_MAGIC","STEALTH","SURVIVAL","TRADE","VAMPIRE"}
    local Skills = ""
    for _, v in pairs(sk) do
      Skills = Skills.."\2"..v
    end
    Note(Skills)]]
    local Skills = "\2SKILLS"
    Bars = "\2HEALTH_MAX\2HEALTH_REGEN\2HEALTH\2MANA_MAX\2MANA_REGEN\2MANA\2MOVEMENT_MAX\2MOVEMENT_REGEN\2MOVEMENT\2BLOOD\2BLOOD_MAX\2BLOOD_UPKEEP" --health mana move blood
    Empire = "\2EMPIRE_RANK\2EMPIRE_NAME\2EMPIRE_TERRITORY\2EMPIRE_TERRITORY_MAX\2EMPIRE_TERRITORY_OUTSIDE\2EMPIRE_TERRITORY_OUTSIDE_MAX" --more stuff
    Other = "\2WORLD_TIME\2WORLD_SEASON\2OPPONENT_HEALTH\2OPPONENT_HEALTH_MAX\2OPPONENT_LEVEL\2OPPONENT_NAME"
    Start = "\255\250\69\1REPORT"
    Mid = Basic..Primary..Secondary..Bars..Skills..Empire..Other
    End = "\2\255\240"
    --
    SendPkt (Start..Mid..End) --I'm legitimately surprised I can send this much data at once without breaking something
    return true
  else -- another protocol
    return false
  end -- if
end -- function OnPluginTelnetRequest

function get_room_string()
  if msdp["ROOM"] == nil or msdp["ROOM"] == "" then
    return nil
  end
  room = unpack_array(msdp["ROOM"])
  local line1 = "["..room["VNUM"].."]\n"
  local line2 = room["NAME"].." ("..room["TERRAIN"]..")\n"
  local line3 = "("..room["COORDS"]["X"]..","..room["COORDS"]["Y"]..") - "..room["AREA"]
  return line1..line2..line3
end


function got_vitals ()      -- eg. "H:496/496 M:412/412 E:1380/1380 W:960/960 NL:89/100"
  local s = nil
  status,err = pcall(function() s = "H:"..msdp["HEALTH"].."/"..msdp["HEALTH_MAX"].." M:"..msdp["MANA"].."/"..msdp["MANA_MAX"].." E:"..msdp["MOVEMENT"].."/"..msdp["MOVEMENT_MAX"].." W:0/0 NL:0/0" end)
  if err then return end
  BroadcastPlugin (1, s)
end -- got_vitals

function got_room_brief ()  -- eg. "Continuing on the Parade of Zarathustra"
  local s = nil
  local room = unpack_array(msdp["ROOM"])
  if room == nil then return end
  status,err = pcall(function() s = room["NAME"] end)
  if err then Note(err) return end
  if s == nil then return end --????
  BroadcastPlugin (2, s)
end -- got_room_brief

function got_room_exits ()  -- eg. "n,s"
  local s = nil
  local room = unpack_array(msdp["ROOM"])
  if room == nil then return end
  status,err = pcall(function() s = room["EXITS"] end)
  if err then Note(err) return end
  if s == nil then s = "ne,s,e,sw,w,se,nw,n" else--outdoors?
    local i=1
    s=""
    for k,v in pairs(room["EXITS"]) do
      if i>1 then
        s=s..","
      end
      i=i+1
      s=s..k
    end
  end
  BroadcastPlugin (3, s)
end -- got_room_exits

function got_room_number ()  -- eg. "441"
  local s = nil
  local room = unpack_array(msdp["ROOM"])
  if room == nil then return end
  status,err = pcall(function() s = room["VNUM"] end)
  if err then Note(err) return end
  BroadcastPlugin (4, s)
end -- got_room_number

function got_full_exits ()  -- eg. "ne(8564),w(8428)"
  local s = nil
  local room = unpack_array(msdp["ROOM"])
  if room == nil then return end
  status,err = pcall(function() s = room["EXITS"] end)
  if err then Note(err) return end
  if s == nil then s="" else --outdoors? we can't get vnums
    local i=1
    s=""
    for k,v in pairs(room["EXITS"]) do
      if i>1 then
        s=s..","
      end
      i=i+1
      s=s..k.."("..v..")"
    end
  end
  BroadcastPlugin (5, s)
end -- got_full_exits

function got_environment ()  -- eg. "Urban"
  local s = nil
  local room = unpack_array(msdp["ROOM"])
  if room == nil then return end
  status,err = pcall(function() s = room["TERRAIN"] end)
  if err then Note(err) return end
  BroadcastPlugin (6, s)
end -- got_environment

function got_coordinates ()  -- eg. "38,3,1,0"  (area,x,y,z)
  local s = nil
  local room = unpack_array(msdp["ROOM"])
  if room == nil then return end
  status,err = pcall(function() s = room["AREA"]..","..room["COORDS"]["X"]..","..room["COORDS"]["Y"]..","..room["COORDS"]["Z"] end) --string.byte(string.sub(msdp["ROOM"]["AREA"], 1, 1))?
  if err then Note(err) return end
  BroadcastPlugin (7, s)
end -- got_coordinates

function got_info ()  -- eg. "shop,postoffice"
  local types = nil
  local room = unpack_array(msdp["ROOM"])
  if room == nil then return end
  status,err = pcall(function() types = room["NAME"] end) --string.byte(string.sub(msdp["ROOM"]["AREA"], 1, 1))?
  if err then Note(err) return end
  local s = ""
  if types=="The Pigeon Post" then s = "postoffice" elseif types=="The Trading Post" then s = "shop" end
  if s == "" then return end
  BroadcastPlugin (8, s)
end -- got_info

handlers = {

  ['Room.Brief']        = got_room_brief,

  ['Room.Exits']        = got_room_exits,
  ['Char.Vitals']       = got_vitals,
  ['Room.FullExits']    = got_full_exits,
  ['Room.Environment']  = got_environment,
  ['Room.Coordinates']  = got_coordinates,
  ['Room.Info']         = got_info,
  ['Room.Num']          = got_room_number,
  
  } -- end handlers
  
function process_mud_time(hour, season)
  local hour_str = "???"
  local short_season = "unknown"
  --hour string
  local hour = tonumber(hour)
  if hour == nil or season == nil then return hour_str, short_season end
  if hour == 0 then hour_str = "12am"
  elseif hour == 12 then hour_str = "12pm"
  elseif hour < 13 then hour_str = hour.."am"
  else hour_str = (hour-12).."pm"
  end
  local seasons = {"spring", "summer", "fall", "autumn", "winter"} 
  for _,v in ipairs(seasons) do
    if string.find(season, v) then short_season = v end
  end
  return hour_str, short_season
end

function OnPluginTelnetSubnegotiation (neg_type, data)
--  Note(data)
  if neg_type == MSDP then
    endpos = string.len(data)
    bName = false
    bValue = false
    bTable = 0
    bIgnore = false
    variable = nil
    value = nil
    if debug_mode then
      Note('Raw data: ['..data..']')
      Note('Formatted: ['..filter(data)..']')
    end
    
    for i=1,endpos,1 do
      if string.byte(data,i) == 1 and bTable == 0 then
        if variable ~= nil and value ~= nil then
          StoreVariable(variable, value)
          variable = nil
          value = nil
        end -- if
        bName = true
        bValue = false
      elseif string.byte(data,i) == 2 and bTable == 0 then
        if value ~= nil then
          value = value.." "
        end -- if
        bName = false
        bValue = true
      elseif string.byte(data,i) == 3 then
        bTable = bTable + 1
        if bTable > 1 then
          if bName == true then
            if variable == nil then
              variable = ""
            end -- if
            variable = variable..string.sub(data,i,i)
          elseif bValue == true then
            if value == nil then
              value = ""
            end -- if
            value = value..string.sub(data,i,i)
          end -- if
        else
          bIgnore = true
        end
      elseif string.byte(data,i) == 4 then
        bTable = bTable - 1
        if bTable > 0 then
          if bName == true then
            if variable == nil then
              variable = ""
            end -- if
            variable = variable..string.sub(data,i,i)
          elseif bValue == true then
            if value == nil then
              value = ""
            end -- if
            value = value..string.sub(data,i,i)
          end -- if
        else
--        bIgnore = true
        end
      elseif bIgnore == true then
        bIgnore = false -- Just ignore one character.
      elseif bName == true then
        if variable == nil then
          variable = ""
        end -- if
        variable = variable..string.sub(data,i,i)
      elseif bValue == true then
        if value == nil then
          value = ""
        end -- if
        value = value..string.sub(data,i,i)
      end -- if
    end -- for

    if variable ~= nil then
      if value == nil then
        value = ""
      end -- if
      StoreVariable(variable, value)
    end -- if

    --  redraw the map
    --draw_minimap ()
    
    -- redraw the enemy score window
    draw_enemy_window ()
    
    -- redraw the score sheet
    draw_score ()

    -- redraw the energy bars
    draw_energy_bars ()

    -- redraw the spell affect icons
    draw_affects ()
    --local test = get_room_string()
    --if test then Note(test) end
--[[    if msdp["ROOM"] ~= nil and msdp["ROOM"] ~= "" then
      room = unpack_array(msdp["ROOM"])
      Note("ROOM: "..msdp["ROOM"])
      Note("Unpacking ROOM")
      if room and not room["EXITS"] then Note("We appear to be outdoors") end
      Note("Unpacked ROOM. Result:")
      for u, i in pairs(room) do
        if type(i)=="table" then
          Note(u)
          for k, v in pairs(i) do
            Note(k..": "..v)
          end
        else
          Note(u..": "..i)
        end
      end
    end]]
    if GetPluginInfo ("c511a7e6a633f2da67d935d3", 17) then --hack-y automapper variant enabled
      for i = 1, 3 do for _,v in pairs(handlers) do v() end end --why this doesn't work the first time I have no idea...
    end
    Redraw()

  end -- if
end -- function OnPluginTelnetSubnegotiation

function StoreVariable (MSDP_var, MSDP_val)
--Note('Variable: '..MSDP_var..' = ['..MSDP_val..']')
  if MSDP_var == "SERVER_ID" then
    create_layout ()
    local vernum = GetPluginInfo(GetPluginID(), 19)
    SendPkt ("\255\250\69\1PLUGIN_ID\2MUSHclient UI for EmpireMUD (version "..vernum..")\255\240")
  else -- store the variable
    if msdp_val ~= nil and msdp_var ~= nil then SetVariable("msdp_"..MSDP_var,msdp_val) else if msdp_var ~= nil then DeleteVariable("msdp_"..msdp_var) end end
    msdp[MSDP_var] = MSDP_val
  end -- if
end -- function StoreVariable

]]>
</script>

</muclient>
